# Scheduling system design

2023-07-29

---

서비스를 만들다 보면 Scheduling이 필요한 경우가 있다.

1. subscription 상품 매월 특정일 결제
1. 메시지 발송 schedule
1. 매주 월 금 repeat 되는 작업(reminder)

## 구독 상품 결제 구현 과정

![Subscription payment](i/2.png "Subscription payment")

내가 구현한 구독 결제의 경우 스케줄러를 직접 만들어 매분 마다 결제 대상 구독데이터를 탐색하고 순차적으로 PG 결체 처리 한 뒤 그 결과를 구독 데이터에 반영하는 방식이었다. PG 결제 처리의 경우 최소 1초 정도 소요 되고 동시 결제 건수는 3건이라는 제약사항이 있었는데 매분하다 1천개씩 탐색하고 순차적으로 결제 하도록 했다.

동시 결제 건수가 3건이기 때문에 1건은 신규 구독 결제를 위해 놔두고 스케줄러는 2개의 스레드를 만들어 Multithread로 동시에 2건식 구독 갱신 결제를 처리 하게 하였다. 이론상 특정일에 결제 대상 유저가 10만 명이라면 소요시간이 `10만(결제 건수) / 2(스레드 수) / 1.08(PG 결제 및 데이터 처리) = 약46000초`가 되므로 하루에 전부 처리 할수 없게 된다. 물론 결제 건수가 이정도로 많다면 진작 PG사와 협의 하여 동시 결제 건수를 상향 해야 할것이다. 하지만 분명한건 **Scalability** 측면에서 부족한점이 보이는것은 사실이다.

## 5분 안에 처리 해야 한다면?

결제는 분, 시간 단위로 처리 될 필요 없이 그 날짜 안에만 처리하면 된다. 하지만 **예약 메시지 기능은 어떨까?** 대부분의 서비스들은 최소 5분 단위로 예약메시지를 보낼수 있는 기능을 제공한다. 1만명의 유저가 15시 15분에 메시지 발송을 예약 했다면 mobile push든 email이든 5분 단위로 사용자가 예약한 그 시점에 정확히 발송처리 해야한다.

## Job Queue System

![Job queue](i/1.png "job queue")

- 여러개의 Server는 queue에 schedule 되는 작업인 Task를 넣는다.
- 여러개의 Worker는 queue에서 Task를 꺼내서 처리한다.

유저는 메시지 발송을 예약하고 취소할 수 있을 건데 큐는 한번 데이터를 쌓으면 쌓인 순서대로 처리 해야한다. 그러면 큐에 쌓인 데이터를 처리하는 worker는 예약이 취소되었는지 체크 해야한다. 예약 취소시 큐에 쌓인 데이터를 직접 제거 하는 방식은 제거 하기 전에 작업이 수행될수 있기 때문에 문제가 있어 보인다.

특정 분 시간에 예약된것이 5천건이라면 worker는 큐에 쌓인 task DB 부하를 줄이기 위해 task를 수행하기 위한 필요한 데이터 모두 큐에 같이 담는것이 DB부하를 줄이는 방법일것이다.

그렇다면 지금이 14시 11분 인데 19시 20분 발송 예약 Task는 언제 큐에 넣어야 할까? 그 즉시 넣으면 당연히 Worker는 바로 Task를 처리하고 실행 될것이다. 별도의 스케줄러가 일괄로 Task를 탐색해서 넣는다면 큐에 넣었는지 여부를 Task 데이터에 담아야 할것이다.
